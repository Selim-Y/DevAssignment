# First we need to make sure that some packages (=places where e.g. commands are 
#saved) are available, for this, we need to install them
#for this, we create a variable called check, (see in your Enviroment 
#what value it takes after having run the line), it takes TRUE if the package is 
#already installed and FALSE if not
check <- require('survey')
#next, we have a loop that has a condition (!check, this condition is TRUE if check is FALSE and FALSE if check is TRUE)
#i.e. if it is already installed, the loop will not do anything, if it is not instaled, it will install it
#Depending on your version, you might need to enter YES in the console to confirm that you want to install it
if(!check) {
  install.packages('survey')
}
#just because it is installed does not mean that it is loaded into your current session (the one you run this file in), therefore we execute the following code
library(survey)  
#to learn about the package
?survey

#now to the next package that will allow us to load the files we have easily into R
check <- require('readstata13')
#if not installed, install the package, this needs to be confirmed by typing in yes in the command console, after having run the following line
if(!check) {
  install.packages('readstata13')
}
library('readstata13')  
#to learn about the package
?readstata13

#some housekeeping
rm(check)

# now finally: Read in data

#for this: we create the filepath either per hand, see the line below, 
#or we use the point-and-shoot-option (often easier if you donot feel comfortable with R or coding yet)

# statafile <- 'u:/interim files/Tanzania 2012.dta' #if you want to use this, delete the # at the beginning and type in the correct path
statafile <- file.choose() #allows for clicking on it in a window, no need to have the path ready
#load it
tzdata2018 <- read.dta13(statafile,nonint.factors = T)

# Remove observations with missing data 
tzdata2018 <- na.omit(tzdata)
#create population-weight (popwt) as a variable
tzdata2018$popwt <- with(tzdata,hhsize*hhweight)

#incorporate the surveydesign: for this, use the information about strata, weights and ID from the data
tzdesign2018 <- svydesign(id = ~CLUSTER, strata = ~STRATUM, weights = ~popwt, data = tzdata)
#

#This is the end for the first round of the survey (either 2012 and 2018), 
#now you will have to repeat the code for the other round, however, no need to load (or install) the packages again, good luck!




library(haven)
library(dplyr)
library(survey)
library(tidyr)
library(knitr)
library(data.table)


dt1 <- as.data.table(read_dta("Datasets/Tanzania_2012.dta"))
dt2 <- as.data.table(read_dta("Datasets/Tanzania_2018.dta"))
setnames(dt1, tolower(names(dt1))); setnames(dt2, tolower(names(dt2)))
dt <- rbindlist(list(dt1, dt2), fill = TRUE)
df <- as.data.frame(dt, stringsAsFactors = FALSE)


cons <- "cons"
year <- "year"
std_var <- "povline"
food_var <- "food_povline"


# build person weight
hh_wt <- "hhweight"
hh_sz <- "hhsize"
if (!is.na(hh_wt) && !is.na(hh_sz)) df$person_wt <- df[[hh_wt]] * df[[hh_sz]] else if (!is.na(hh_wt)) df$person_wt <- df[[hh_wt]] else if ("person_wt" %in% names(df)) df$person_wt <- df$person_wt else df$person_wt <- 1

# build area_group
area_var <- "area"
region_var <- "region"
df$area_group <- NA_character_
if (!is.na(region_var)) df[grepl("dar", tolower(as.character(df[[region_var]]))), "area_group"] <- "Dar es Salaam"
if (!is.na(area_var)) {
  isUrban <- grepl("urban|town|city", tolower(as.character(df[[area_var]])))
  isRural <- grepl("rural|village", tolower(as.character(df[[area_var]])))
  df$area_group[is.na(df$area_group) & isUrban] <- "Other urban"
  df$area_group[is.na(df$area_group) & isRural] <- "Rural"
}
df$area_group[is.na(df$area_group)] <- "Rural"

measures <- function(cons_v, wt_v, z) {
  if (is.na(z)) return(c(h = NA_real_, g = NA_real_, sg = NA_real_))
  poor <- cons_v < z
  S <- sum(wt_v, na.rm = TRUE)
  if (S <= 0) return(c(h = NA_real_, g = NA_real_, sg = NA_real_))
  h <- sum(wt_v * poor, na.rm = TRUE) / S
  gap <- pmax(0, (z - cons_v) / z)
  g <- sum(wt_v * gap, na.rm = TRUE) / S
  sg <- sum(wt_v * gap^2, na.rm = TRUE) / S
  c(h = h, g = g, sg = sg)
}

compute_by_group <- function(df, z, group_col = NULL, povlabel = "standard", level_name = NULL) {
  if (is.null(group_col)) {
    m <- measures(df$cons, df$person_wt, z)
    return(data.frame(level = "National", group = "All", povline = povlabel,
                      headcount = m["h"], poverty_gap = m["g"], sq_poverty_gap = m["sg"],
                      stringsAsFactors = FALSE))
  }
  vals <- unique(df[[group_col]])
  out <- lapply(vals, function(g) {
    sub <- df[df[[group_col]] == g, , drop = FALSE]
    m <- measures(sub$cons, sub$person_wt, z)
    data.frame(level = ifelse(is.null(level_name), group_col, level_name),
               group = as.character(g), povline = povlabel,
               headcount = m["h"], poverty_gap = m["g"], sq_poverty_gap = m["sg"],
               stringsAsFactors = FALSE)
  })
  do.call(rbind, out)
}


cons <- "cons"    
year <- "year"
std_var <- "povline"
food_var <- "food_povline"
region_var <- if ("region" %in% names(df)) "region" else NA
area_col <- "area_group"

yrs <- sort(unique(df[[year]]))
results <- list()
for (y in yrs) {
  sub <- df[df[[year]] == y, , drop = FALSE]
  z_std  <- if (length(unique(na.omit(sub[[std_var]])))>0) unique(na.omit(sub[[std_var]]))[1] else NA_real_
  z_food <- if (length(unique(na.omit(sub[[food_var]])))>0) unique(na.omit(sub[[food_var]]))[1] else NA_real_
  results[[length(results)+1]] <- compute_by_group(sub, z_std, NULL, "standard")
  results[[length(results)+1]] <- compute_by_group(sub, z_std, area_col, "standard", "Area")
  if (!is.na(region_var)) results[[length(results)+1]] <- compute_by_group(sub, z_std, region_var, "standard", "Region")
  results[[length(results)+1]] <- compute_by_group(sub, z_food, NULL, "food")
  results[[length(results)+1]] <- compute_by_group(sub, z_food, area_col, "food", "Area")
  if (!is.na(region_var)) results[[length(results)+1]] <- compute_by_group(sub, z_food, region_var, "food", "Region")
}
res <- do.call(rbind, results)
res$year <- rep(yrs, each = nrow(res)/length(yrs))

res[, c("headcount","poverty_gap","sq_poverty_gap")] <- lapply(res[, c("headcount","poverty_gap","sq_poverty_gap")], as.numeric)
write.csv(res, "output/poverty_measures.csv", row.names = FALSE)
print(head(res, 30))







library(haven)

files <- c("Datasets/Tanzania_2012.dta", "Datasets/Tanzania_2018.dta")

for (f in files) {
  df <- read_dta(f)
  
  # basic checks
  if (!"cons" %in% names(df)) {
    message("Skipping ", f, ": 'cons' not found.")
    next
  }
  if (!"povline" %in% names(df)) {
    message("Skipping ", f, ": 'povline' not found.")
    next
  }
  
  # make indicator: 1 if cons < povline, 0 otherwise; keep NA where input NA
  df$below_pov <- ifelse(is.na(df$cons) | is.na(df$povline), NA,
                         ifelse(df$cons < df$povline, 1, 0))
  
  # quick summary
  n_total <- sum(!is.na(df$below_pov))
  n_below <- sum(df$below_pov == 1, na.rm = TRUE)
  prop_below <- if (n_total > 0) n_below / n_total else NA
  
  cat("\nFile:", f, "\n")
  cat("Observations with cons & povline:", n_total, "\n")
  cat("Households below poverty line:", n_below, "\n")
  cat("Share below poverty line:", round(prop_below, 4), "\n")
  
  # save
  out_csv <- sub("\\.dta$", "_with_poverty.csv", basename(f))
  write.csv(df, out_csv, row.names = FALSE)
  cat("Saved:", out_csv, "\n")
  
  
  
  
  
  
  d <- read_dta("Datasets/Tanzania_2018.dta")
  
  # map STRATUM -> location
  d$location <- ifelse(d$STRATUM %in% c(1, "1"), "rural",
                       ifelse(d$STRATUM %in% c(2, "2"), "urban",
                              ifelse(d$STRATUM %in% c(3, "3"), "dar es salaam", NA)))
  
  # keep households below poverty with children
  sel <- (d$cons < d$povline) & !is.na(d$ch14) & d$ch14 > 0
  d <- d[sel, , drop = FALSE]
  if (nrow(d) == 0) stop("No households below poverty with children found.")
  
  # enrolled children by rule: educlevel_hhh >= 3 -> all ch14 enrolled, else 0
  d$enrolled <- ifelse(d$educlevel_hhh >= 3, d$ch14, 0)
  d$total   <- d$ch14
  
  # survey design (household weight)
  svy <- svydesign(id = ~1, weights = ~hhweight, data = d)
  
  # weighted ratio by location x sex_hhh
  res <- svyby(~enrolled, ~location + sex_hhh, svy, svyratio, denominator = ~total, na.rm = TRUE)
  
  # find estimate and se columns (robust)
  group_cols <- c("location","sex_hhh")
  est_col <- setdiff(names(res), group_cols)[1]
  se_col_candidates <- grep(paste0("^", est_col, "(_se|\\.se$|__se$)"), names(res), value = TRUE)
  if (length(se_col_candidates) == 0) se_col_candidates <- grep("(_se$|\\.se$|se$)", names(res), value = TRUE)
  se_col <- if (length(se_col_candidates) > 0) se_col_candidates[1] else NA
  
  # build result df
  res_df <- data.frame(
    location = res$location,
    sex = res$sex_hhh,
    estimate = res[[est_col]],
    se = if (!is.na(se_col)) res[[se_col]] else NA_real_,
    stringsAsFactors = FALSE
  )
  res_df$percent <- 100 * res_df$estimate
  res_df$se_pct  <- 100 * res_df$se
  res_df$display <- ifelse(is.na(res_df$percent), NA, sprintf("%.1f (Â±%.1f)", res_df$percent, res_df$se_pct))
  
  # label sexes for columns
  res_df$sex_label <- ifelse(res_df$sex %in% c(2,"2","F","f","Female","female"), "Female",
                             ifelse(res_df$sex %in% c(1,"1","M","m","Male","male"), "Male",
                                    as.character(res_df$sex)))
  
  # pivot wide (base R)
  wide <- reshape(res_df[, c("location","sex_label","display")],
                  idvar = "location", timevar = "sex_label",
                  direction = "wide")
  # tidy column names
  names(wide) <- sub("^display\\.", "", names(wide))
  
  # ensure order
  order_pref <- c("rural","urban","dar es salaam")
  wide$location <- factor(wide$location, levels = order_pref)
  wide <- wide[order(wide$location, na.last = TRUE), , drop = FALSE]
  
  # replace NA with "-"
  wide[is.na(wide)] <- "-"
  
  # print table
  print(wide, row.names = FALSE)
  
  # open viewer if interactive
  if (interactive()) View(wide)
  
  
  
  d <- read_dta("Datasets/Tanzania_2018.dta")
  
  # keep only observations with treatment and outcome
  d <- subset(d, !is.na(freebooks) & !is.na(inschool_later))
  
  # survey design using STRATUM as strata and hhweight as weight
  svy <- svydesign(id = ~1, strata = ~STRATUM, weights = ~hhweight, data = d)
  
  # group means (control = freebooks==0, treat = freebooks==1)
  group_means <- svyby(~inschool_later, ~freebooks, svy, svymean, na.rm = TRUE)
  
  # difference in means via linear survey regression (identity link)
  fit <- svyglm(inschool_later ~ freebooks, design = svy, family = gaussian())
  s <- summary(fit)
  diff_est <- coef(fit)["freebooks"]                     # difference in proportions (treat - control)
  diff_se  <- s$coef["freebooks","Std. Error"]
  diff_p   <- s$coef["freebooks","Pr(>|t|)"]
  
  # prepare table: control mean, treatment mean, diff (pct points), SE and p-value
  control_mean  <- as.numeric(group_means$inschool_later[group_means$freebooks == 0])
  treat_mean    <- as.numeric(group_means$inschool_later[group_means$freebooks == 1])
  tab <- data.frame(
    group = c("Control","Treatment","Difference (T-C)"),
    proportion = c(control_mean, treat_mean, diff_est),
    se = c(NA, NA, diff_se),
    p_value = c(NA, NA, diff_p),
    stringsAsFactors = FALSE
  )
  # convert to percent for display
  tab$percent <- round(100 * tab$proportion, 2)
  tab$se_pct <- ifelse(is.na(tab$se), NA, round(100 * tab$se, 2))
  
  # print a simple table to console (screenshot this)
  print(tab[, c("group","percent","se_pct","p_value")], row.names = FALSE)
  
  # build a short paragraph for the policy note and append it
  paragraph <- sprintf(
    "An RCT conducted in 2017 provided free school books to a random subset of children. In our analysis of later enrollment (inschool_later), the treatment group had %.2f%% enrolled vs %.2f%% in the control group, a difference of %.2f percentage points (SE = %.2f p = %.3f). This suggests that free books %s increase enrollment in this sample.",
    100 * treat_mean,
    100 * control_mean,
    100 * diff_est,
    100 * diff_se,
    diff_p,
    ifelse(diff_p < 0.05 & diff_est > 0, "did",
           ifelse(diff_p < 0.05 & diff_est < 0, "reduced",
                  "did not robustly"))
  )
  
  cat("\n--- Findings paragraph (also appended to policy_note.txt) ---\n")
  cat(paragraph, "\n")
  
  # append to policy note file
  cat("\n", paragraph, file = "policy_note.txt", append = TRUE)