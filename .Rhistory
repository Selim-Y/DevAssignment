cat("\nEffect of free books on later enrollment (inschool_later)\n")
print(tab[, c("group","percent","se_pct","p_value")], row.names = FALSE)
d <- read_dta("Datasets/Tanzania_2018_new-3.dta")
for (f in files) {
df <- read_dta(d)
}
d <- read_dta("Datasets/Tanzania_2018_new-3.dta")
df <- read_dta(d)
file_path <- "Datasets/Tanzania_2018_new-3.dta"
# make indicator: 1 if cons < povline, 0 otherwise; keep NA where input NA
df$below_pov <-   ifelse(df$cons < df$povline, 1, 0)
# quick summary
n_total <- sum(!is.na(df$below_pov))
n_below <- sum(df$below_pov == 1, na.rm = TRUE)
prop_below <- if (n_total > 0) n_below / n_total else NA
cat("File:", file_path, "\n")
cat("Observations with cons & povline:", n_total, "\n")
cat("Households below poverty line:", n_below, "\n")
cat("Share below poverty line:", round(prop_below, 4), "\n")
# save
out_csv <- sub("\\.dta$", "_with_poverty.csv", basename(file_path))
write.csv(df, out_csv, row.names = FALSE)
cat("Saved:", out_csv, "\n")
file_path <- "Datasets/Tanzania_2018_new-3.dta"
df <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 otherwise
df$below_pov <- ifelse(df$cons < df$povline, 1, 0)
# add variable to dataset
write_dta(df, file_path)
View(Tanzania_2018_new_3)
file_path <- "Datasets/Tanzania_2018_new-3.dta"
df <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 otherwise
df$below_pov <- ifelse(df$cons < df$povline, 1L, 0L)
# add variable to dataset
write_dta(df, file_path)
file_path <- "Datasets/Tanzania_2018_new-3.dta"
df <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 otherwise
df$below_pov <- ifelse(df$cons < df$povline, 1, 0)
# write back (overwrite)
write_dta(df, file_path)
# verify: read back and print a short confirmation
df_check <- read_dta(file_path)
cat("Wrote file:", file_path, "\n")
cat("Variable present?:", "below_pov" %in% names(df_check), "\n")
if ("below_pov" %in% names(df_check)) {
cat("Non-missing / missing counts:", sum(!is.na(df_check$below_pov)), "/", sum(is.na(df_check$below_pov)), "\n")
print(head(df_check$below_pov, 10))
}
rm(list = ls())
file_path <- "Datasets/Tanzania_2018_new-3.dta"
if (!file.exists(file_path)) stop("File not found: ", file_path)
# read
df <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 if cons >= povline
df$below_pov <- ifelse(df$cons < df$povline, 1L, 0L)
# write back (overwrite)
write_dta(df, file_path)
View(df)
file_path <- "Datasets/Tanzania_2018_new-3.dta"
# read
Tanzania_2018_below_pov <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 if cons >= povline
Tanzania_2018_below_pov$below_pov <- ifelse(Tanzania_2018_below_pov$cons < Tanzania_2018_below_pov$povline, 1, 0)
# write back (overwrite)
write_dta(Tanzania_2018_below_pov, file_path)
View(Tanzania_2018_below_pov)
# below-poverty households and valid observations in age 7-18
sel <- (Tanzania_2018_below_pov$cons < Tanzania_2018_below_pov$povline) & !is.na(Tanzania_2018_below_pov$inschool) & !is.na(Tanzania_2018_below_pov$male) & !is.na(Tanzania_2018_below_pov$rural) & !is.na(Tanzania_2018_below_pov$age) & Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 18
Tanzania_2018_below_pov <- Tanzania_2018_below_pov[sel, , drop = FALSE]
# create age group variable
Tanzania_2018_below_pov$agegrp <- ifelse(Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 12, "7-12", "13-18")
# survey design using household weight
svy <- svydesign(id = ~1, weights = ~hhweight, data = Tanzania_2018_below_pov)
# weighted mean of inschool by rural + male + agegrp
res <- svyby(~inschool, ~rural + male + agegrp, svy, svymean, na.rm = TRUE)
# identify estimate and se columns robustly
group_cols <- c("rural","male","agegrp")
est_col <- setdiff(names(res), group_cols)[1]
se_col_candidates <- grep(paste0("^", est_col, "(_se|\\.se$|__se$)"), names(res), value = TRUE)
if (length(se_col_candidates) == 0) se_col_candidates <- grep("(_se$|\\.se$|se$)", names(res), value = TRUE)
se_col <- if (length(se_col_candidates) > 0) se_col_candidates[1] else NA
# build result frame and labels
res_df <- data.frame(
rural = res$rural,
male = res$male,
agegrp = res$agegrp,
estimate = res[[est_col]],
se = if (!is.na(se_col)) res[[se_col]] else NA_real_,
stringsAsFactors = FALSE
)
# map codes to readable labels
res_df$location <- ifelse(res_df$rural %in% c(1, "1", TRUE), "rural", "urban")
res_df$sex_label <- ifelse(res_df$male %in% c(1, "1", TRUE), "Male", "Female")
res_df$percent <- 100 * res_df$estimate
res_df$se_pct  <- 100 * res_df$se
res_df$display <- ifelse(is.na(res_df$percent), NA, sprintf("%.1f (±%.1f)", res_df$percent, res_df$se_pct))
# create column name combining sex and age group, then pivot wide (base R)
res_df$colname <- paste(res_df$sex_label, res_df$agegrp)
wide <- reshape(res_df[, c("location","colname","display")],
idvar = "location", timevar = "colname", direction = "wide")
names(wide) <- sub("^display\\.", "", names(wide))
# ensure order: urban then rural (rural variable uses 0 = urban, 1 = rural)
order_pref <- c("urban","rural")
wide$location <- factor(wide$location, levels = order_pref)
wide <- wide[order(wide$location, na.last = TRUE), , drop = FALSE]
# replace NA with "-"
wide[is.na(wide)] <- "-"
# print table
print(wide, row.names = FALSE)
if (interactive()) View(wide)
View(res_df)
# keep observations with treatment and outcome
Tanzania_2018_below_pov <- subset(Tanzania_2018_below_pov, !is.na(freebooks) & !is.na(inschool_later))
# survey design: use STRATUM if present, otherwise unstratified
if ("STRATUM" %in% names(Tanzania_2018_below_pov)) {
svy <- svydesign(id = ~1, strata = ~STRATUM, weights = ~hhweight, data = Tanzania_2018_below_pov)
} else {
svy <- svydesign(id = ~1, weights = ~hhweight, data = Tanzania_2018_below_pov)
}
# group means (proportions) by freebooks (0 = control, 1 = treatment)
grp <- svyby(~inschool_later, ~freebooks, svy, svymean, na.rm = TRUE)
# difference in means via linear survey regression (identity link)
fit <- svyglm(inschool_later ~ freebooks, design = svy, family = gaussian())
s <- summary(fit)
# extract numbers
control_mean <- as.numeric(grp$inschool_later[grp$freebooks == 0])
treat_mean   <- as.numeric(grp$inschool_later[grp$freebooks == 1])
diff_est     <- coef(fit)["freebooks"]
diff_se      <- s$coef["freebooks","Std. Error"]
diff_p       <- s$coef["freebooks","Pr(>|t|)"]
# prepare and print compact table
tab <- data.frame(
group = c("Control (freebooks=0)", "Treatment (freebooks=1)", "Difference (T - C)"),
proportion = c(control_mean, treat_mean, diff_est),
se = c(NA, NA, diff_se),
p_value = c(NA, NA, diff_p),
stringsAsFactors = FALSE
)
tab$percent <- round(100 * tab$proportion, 2)
tab$se_pct  <- ifelse(is.na(tab$se), NA, round(100 * tab$se, 2))
cat("\nEffect of free books on later enrollment (inschool_later) — Tanzania_2018_new-3.dta\n")
print(tab[, c("group","percent","se_pct","p_value")], row.names = FALSE)
# keep observations with treatment and outcome
Tanzania_2018_below_pov <- subset(Tanzania_2018_below_pov, !is.na(freebooks) & !is.na(inschool_later))
# survey design: use STRATUM
svy <- svydesign(id = ~1, strata = ~STRATUM, weights = ~hhweight, data = Tanzania_2018_below_pov)
# group means (proportions) by free books (0 = control, 1 = treatment)
grp <- svyby(~inschool_later, ~freebooks, svy, svymean, na.rm = TRUE)
# difference in means via linear survey regression (identity link)
fit <- svyglm(inschool_later ~ freebooks, design = svy, family = gaussian())
s <- summary(fit)
# extract numbers
control_mean <- as.numeric(grp$inschool_later[grp$freebooks == 0])
treat_mean   <- as.numeric(grp$inschool_later[grp$freebooks == 1])
diff_est     <- coef(fit)["freebooks"]
diff_se      <- s$coef["freebooks","Std. Error"]
diff_p       <- s$coef["freebooks","Pr(>|t|)"]
# prepare and print compact table
tab <- data.frame(
group = c("Control (freebooks=0)", "Treatment (freebooks=1)", "Difference (T - C)"),
proportion = c(control_mean, treat_mean, diff_est),
se = c(NA, NA, diff_se),
p_value = c(NA, NA, diff_p),
stringsAsFactors = FALSE
)
tab$percent <- round(100 * tab$proportion, 2)
tab$se_pct  <- ifelse(is.na(tab$se), NA, round(100 * tab$se, 2))
cat("\nEffect of free books on later enrollment (inschool_later) — Tanzania_2018_new-3.dta\n")
print(tab[, c("group","percent","se_pct","p_value")], row.names = FALSE)
# below-poverty households and valid observations in age 7-18
sel <- (Tanzania_2018_below_pov$cons < Tanzania_2018_below_pov$povline) & !is.na(Tanzania_2018_below_pov$inschool) & !is.na(Tanzania_2018_below_pov$male) & !is.na(Tanzania_2018_below_pov$rural) & !is.na(Tanzania_2018_below_pov$age) & Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 18
Tanzania_2018_below_pov <- Tanzania_2018_below_pov[sel, , drop = FALSE]
# create age group variable
Tanzania_2018_below_pov$agegrp <- ifelse(Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 12, "7-12", "13-18")
# survey design using household weight
svy <- svydesign(id = ~1, weights = ~hhweight, data = Tanzania_2018_below_pov)
# weighted mean of inschool by rural + male + agegrp
res <- svyby(~inschool, ~rural + male + agegrp, svy, svymean, na.rm = TRUE)
# identify estimate and se columns robustly
group_cols <- c("rural","male","agegrp")
est_col <- setdiff(names(res), group_cols)[1]
se_col_candidates <- grep(paste0("^", est_col, "(_se|\\.se$|__se$)"), names(res), value = TRUE)
if (length(se_col_candidates) == 0) se_col_candidates <- grep("(_se$|\\.se$|se$)", names(res), value = TRUE)
se_col <- if (length(se_col_candidates) > 0) se_col_candidates[1] else NA
# build result frame and labels
res_df <- data.frame(
rural = res$rural,
male = res$male,
agegrp = res$agegrp,
estimate = res[[est_col]],
se = if (!is.na(se_col)) res[[se_col]] else NA_real_,
stringsAsFactors = FALSE
)
# map codes to readable labels
res_df$location <- ifelse(res_df$rural %in% c(1, "1", TRUE), "rural", "urban")
res_df$sex_label <- ifelse(res_df$male %in% c(1, "1", TRUE), "Male", "Female")
res_df$percent <- 100 * res_df$estimate
res_df$se_pct  <- 100 * res_df$se
res_df$display <- ifelse(is.na(res_df$percent), NA, sprintf("%.1f (±%.1f)", res_df$percent, res_df$se_pct))
# create column name combining sex and age group
res_df$colname <- paste(res_df$sex_label, res_df$agegrp)
wide <- reshape(res_df[, c("location","colname","display")],
idvar = "location", timevar = "colname", direction = "wide")
names(wide) <- sub("^display\\.", "", names(wide))
# ensure order: urban then rural (rural variable uses 0 = urban, 1 = rural)
order_pref <- c("urban","rural")
wide$location <- factor(wide$location, levels = order_pref)
wide <- wide[order(wide$location, na.last = TRUE), , drop = FALSE]
# print table
print(wide, row.names = FALSE)
View(wide)
# below-poverty households and valid observations in age 7-18
sel <- (Tanzania_2018_below_pov$cons < Tanzania_2018_below_pov$povline) & !is.na(Tanzania_2018_below_pov$inschool) & !is.na(Tanzania_2018_below_pov$male) & !is.na(Tanzania_2018_below_pov$rural) & !is.na(Tanzania_2018_below_pov$age) & Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 18
Tanzania_2018_below_pov <- Tanzania_2018_below_pov[sel, , drop = FALSE]
# create age group variable
Tanzania_2018_below_pov$agegrp <- ifelse(Tanzania_2018_below_pov$age >= 7 & Tanzania_2018_below_pov$age <= 12, "7-12", "13-18")
# survey design using household weight
svy <- svydesign(id = ~1, weights = ~hhweight, data = Tanzania_2018_below_pov)
# weighted mean of inschool by rural + male + agegrp
res <- svyby(~inschool, ~rural + male + agegrp, svy, svymean, na.rm = TRUE)
# identify estimate and se columns robustly
group_cols <- c("rural","male","agegrp")
est_col <- setdiff(names(res), group_cols)[1]
se_col_candidates <- grep(paste0("^", est_col, "(_se|\\.se$|__se$)"), names(res), value = TRUE)
if (length(se_col_candidates) == 0) se_col_candidates <- grep("(_se$|\\.se$|se$)", names(res), value = TRUE)
se_col <- if (length(se_col_candidates) > 0) se_col_candidates[1] else NA
# build result frame and labels
res_df <- data.frame(
rural = res$rural,
male = res$male,
agegrp = res$agegrp,
estimate = res[[est_col]],
se = if (!is.na(se_col)) res[[se_col]] else NA_real_,
stringsAsFactors = FALSE
)
wide <- res_df %>%
mutate(
# map codes to readable labels (rural: 1 => "rural", else "urban")
location = if_else(rural %in% c(1, "1", TRUE), "rural", "urban"),
sex = if_else(male %in% c(1, "1", TRUE), "Male", "Female"),
# percent and se in percentage points
percent = 100 * estimate,
se_pct  = 100 * se,
# formatted display string, NA preserved
display = if_else(is.na(percent), NA_character_, sprintf("%.1f (±%.1f)", percent, se_pct)),
# combined column name
colname = paste(sex, agegrp)
) %>%
select(location, colname, display) %>%
pivot_wider(names_from = colname, values_from = display) %>%
# ensure order: urban then rural
mutate(location = factor(location, levels = c("urban", "rural"))) %>%
arrange(location)
# replace NA displays with "-" for readability
wide[is.na(wide)] <- "-"
# print result
print(wide, row.names = FALSE)
View(wide)
print(wide)
# keep observations with treatment and outcome
Tanzania_2018_below_pov <- subset(Tanzania_2018_below_pov, !is.na(freebooks) & !is.na(inschool_later))
# survey design: use STRATUM
svy <- svydesign(id = ~1, strata = ~STRATUM, weights = ~hhweight, data = Tanzania_2018_below_pov)
# group means (proportions) by free books (0 = control, 1 = treatment)
grp <- svyby(~inschool_later, ~freebooks, svy, svymean, na.rm = TRUE)
# difference in means via linear survey regression
fit <- svyglm(inschool_later ~ freebooks, design = svy, family = gaussian())
s <- summary(fit)
# extract numbers
control_mean <- as.numeric(grp$inschool_later[grp$freebooks == 0])
treat_mean   <- as.numeric(grp$inschool_later[grp$freebooks == 1])
diff_est     <- coef(fit)["freebooks"]
diff_se      <- s$coef["freebooks","Std. Error"]
diff_p       <- s$coef["freebooks","Pr(>|t|)"]
# prepare and print compact table
tab <- data.frame(
group = c("Control (freebooks=0)", "Treatment (freebooks=1)", "Difference (T - C)"),
proportion = c(control_mean, treat_mean, diff_est),
se = c(NA, NA, diff_se),
p_value = c(NA, NA, diff_p),
stringsAsFactors = FALSE
)
tab$percent <- round(100 * tab$proportion, 2)
tab$se_pct  <- ifelse(is.na(tab$se), NA, round(100 * tab$se, 2))
cat("\nEffect of free books on later enrollment (inschool_later) — Tanzania_2018_new-3.dta\n")
print(tab[, c("group","percent","se_pct","p_value")], row.names = FALSE)
View(fit)
print(tab[, c("group","percent","se_pct","p_value")])
mean(Tanzania_2018_below_pov$below_pov) * 100
file_path <- "Datasets/Tanzania_2018_new-3.dta"
# read
Tanzania_2018_below_pov <- read_dta(file_path)
# create below_pov: 1 if cons < povline, 0 if cons >= povline
Tanzania_2018_below_pov$below_pov <- ifelse(Tanzania_2018_below_pov$cons < Tanzania_2018_below_pov$povline, 1, 0)
# write back (overwrite)
write_dta(Tanzania_2018_below_pov, file_path)
mean(Tanzania_2018_below_pov$below_pov) * 100
library(stargazer)
install.packages("tidyverse")
library(stargazer)
install.packages("stargazer")
install.packages("sjPlot")
library(stargazer)
library(tidyverse)
library(sjPlot)
data <- read_csv(file = "monocentric_2016.csv")
data <- read_csv(file = "Datasets/monocentric_2016.csv")
View(data)
# Get descriptive histogram
hist(data$pricem2)
# Get descriptives
summary(data)
# make scatterplot between pricem2 and hhsize (base R)
plot(data$pricem2 ~ data$hhsize)
# First regression with prices per m2 regressed on household size
model_1 <- lm(pricem2 ~ hhsize, data = data)
plot_model(model_1, type = "pred", terms = c("hhsize"))
# Create new variable for Eindhoven dummy
data$Eindhoven <- data$munname == "Eindhoven"
data$Eindhoven <- as.factor(data$Eindhoven) # coerce into factor
# Regression with interaction terms
model_2 <- lm(pricem2 ~ hhsize + Eindhoven + hhsize:Eindhoven, data = data)
summary(model_2)
# Interaction plotting with ggplot2
plot_model(model_2, type = "pred", terms = c("hhsize", "Eindhoven"))
# And combine with schatterplot
plot_model(model_2, type = "pred", terms = c("hhsize", "Eindhoven")) +
geom_point(data = data, aes(x = hhsize, y = pricem2), inherit.aes = FALSE)
# Interaction plotting with base R
plot(data$hhsize, data$pricem2,
pch = 20,
col = "steelblue",
main = "Interaction between household size and Eindhoven",
xlab = "Household size",
ylab = "Housing price per m2",
cex.main=1.2)
coef_m2 <- model_2$coefficients
abline(coef = c(coef_m2[1], coef_m2[2]),
col = "red",
lwd = 2)
abline(coef = c(coef_m2[1] + coef_m2[3], coef_m2[2] + coef_m2[4]),
col = "purple",
lwd = 2)
hist(data$pricem2)
summary(data)
plot(data$pricem2 ~ data$hhsize)
model_1 <- lm(pricem2 ~ hhsize, data = data)
plot_model(model_1, type = "pred", terms = c("hhsize"))
data$leeuwarden <- data$munname == "Eindhoven"
data$leeuwarden <- as.factor(data$leeuwarden) # coerce into factor
model_2 <- lm(pricem2 ~ hhsize + Eindhoven + hhsize:Eindhoven, data = data)
summary(model_2)
plot_model(model_2, type = "pred", terms = c("hhsize", "Eindhoven"))
# And combine with schatterplot
plot_model(model_2, type = "pred", terms = c("hhsize", "Eindhoven")) +
geom_point(data = data, aes(x = hhsize, y = pricem2), inherit.aes = FALSE)
plot(data$hhsize, data$pricem2,
pch = 20,
col = "steelblue",
main = "Interaction between household size and Eindhoven",
xlab = "Household size",
ylab = "Housing price per m2",
cex.main=1.2)
coef_m2 <- model_2$coefficients
abline(coef = c(coef_m2[1], coef_m2[2]),
col = "red",
lwd = 2)
abline(coef = c(coef_m2[1] + coef_m2[3], coef_m2[2] + coef_m2[4]),
col = "purple",
lwd = 2)
eps <- 1e-6
df$log_land <- log(df$land_c + eps)
# Create logs (small epsilon to avoid log(0))
eps <- 1e-6
dat$log_land <- log(dat$land_c + eps)
# Create logs (small epsilon to avoid log(0))
eps <- 1e-6
data$log_land <- log(data$land_c + eps)
code_string <- "vars <- c('land_c','log_land','dist_c','log_dist','log_popdens','control1','control2')
vars_present <- intersect(vars, names(dat))
if (length(vars_present) == 0) stop('No variables from the list found in dat')
tab <- sapply(dat[vars_present], function(x) c(mean = mean(x, na.rm = TRUE),
sd = sd(x, na.rm = TRUE),
min = min(x, na.rm = TRUE),
p25 = quantile(x, 0.25, na.rm = TRUE),
median = median(x, na.rm = TRUE),
p75 = quantile(x, 0.75, na.rm = TRUE),
max = max(x, na.rm = TRUE)))
print(round(tab, 3))"
code_string <- vars <- c('land_c','log_land','dist_c','log_dist','log_popdens','control1','control2')
vars_present <- intersect(vars, names(dat))
code_string <- vars <- c('land_c','log_land','dist_c','log_dist','log_popdens','control1','control2')
vars_present <- intersect(vars, names(data))
if (length(vars_present) == 0) stop('No variables from the list found in data')
rm(list = ls())
target_city <- "Eindhoven"
target_city <- "Eindhoven"
mun_col  <- "munname"
land_col <- "landrent"
dist_col <- "distCBD"
pop_col  <- "popdens"  # optional
needed <- c(mun_col, land_col, dist_col)
miss <- needed[!needed %in% names(data)]
if (length(miss) > 0) stop("Missing columns: ", paste(miss, collapse = ", "))
data <- read_csv(file = "Datasets/monocentric_2016.csv")
target_city <- "Eindhoven"
mun_col  <- "munname"
land_col <- "landrent"
dist_col <- "distCBD"
pop_col  <- "popdens"
needed <- c(mun_col, land_col, dist_col)
miss <- needed[!needed %in% names(data)]
if (length(miss) > 0) stop("Missing columns: ", paste(miss, collapse = ", "))
mun_col  <- "munname"
land_col <- "pricem2"
dist_col <- "distcbd"
pop_col  <- "popdens"
needed <- c(mun_col, land_col, dist_col)
miss <- needed[!needed %in% names(data)]
if (length(miss) > 0) stop("Missing columns: ", paste(miss, collapse = ", "))
# ---- Small cleaning and flags ----
data <- data[!is.na(data[[land_col]]) & !is.na(data[[dist_col]]), ]
data$is_eindhoven <- ifelse(data[[mun_col]] == target_city, 1, 0)
cat("Rows in", target_city, ":", sum(data$is_eindhoven == 1), "\n")
# ---- Winsor cap function ----
cap01 <- function(x) {
q <- quantile(x, probs = c(0.01, 0.99), na.rm = TRUE)
pmin(pmax(x, q[1]), q[2])
}
data$land_c <- cap01(data[[land_col]])
data$dist_c <- cap01(data[[dist_col]])
# Create logs (small epsilon to avoid log(0))
eps <- 1e-6
data$log_land <- log(data$land_c + eps)
data$log_dist <- log(data$dist_c + eps)
# Log population density if available and positive
has_pop <- pop_col %in% names(data)
if (has_pop) {
data$log_popdens <- ifelse(data[[pop_col]] > 0, log(data[[pop_col]] + eps), NA)
}
code_string <- vars <- c('land_c','log_land','dist_c','log_dist','log_popdens','control1','control2')
vars_present <- intersect(vars, names(data))
if (length(vars_present) == 0) stop('No variables from the list found in data')
tab <- sapply(data[vars_present], function(x) c(mean = mean(x, na.rm = TRUE),
sd = sd(x, na.rm = TRUE),
min = min(x, na.rm = TRUE),
p25 = quantile(x, 0.25, na.rm = TRUE),
median = median(x, na.rm = TRUE),
p75 = quantile(x, 0.75, na.rm = TRUE),
max = max(x, na.rm = TRUE)))
print(round(tab, 3))
# Variables to include (edit to add other control names)
vars <- c("land_c","log_land","dist_c","log_dist","log_popdens")
vars <- intersect(vars, names(data))              # keep only present ones
# Helper to make one-row summary for a numeric vector
summ_one <- function(x, name) {
xnum <- as.numeric(x)
m <- mean(xnum, na.rm = TRUE)
s <- sd(xnum, na.rm = TRUE)
mn <- min(xnum, na.rm = TRUE)
p25 <- quantile(xnum, 0.25, na.rm = TRUE)
med <- median(xnum, na.rm = TRUE)
p75 <- quantile(xnum, 0.75, na.rm = TRUE)
mx <- max(xnum, na.rm = TRUE)
cv <- ifelse(!is.na(m) & m != 0, s / m, NA)
# geometric mean: for logged vars we can back-transform exp(mean(log_var))
geom_mean <- NA
backtrans <- NA
if (grepl("^log_", name)) {
# mean of log variable -> back-transform gives a multiplicative "typical" value
geom_mean <- exp(m)
backtrans <- geom_mean
} else if (all(xnum > 0, na.rm = TRUE)) {
# positive-level variable -> geometric mean via exp(mean(log(x)))
geom_mean <- exp(mean(log(xnum), na.rm = TRUE))
}
data.frame(
variable = name,
mean = m,
sd = s,
cv = cv,
min = mn,
p25 = p25,
median = med,
p75 = p75,
max = mx,
geom_mean = geom_mean,
backtrans_from_log = backtrans,
stringsAsFactors = FALSE
)
}
# Build table
rows <- lapply(vars, function(v) summ_one(data[[v]], v))
tab <- do.call(rbind, rows)
# Round numbers to 3 decimals for printing
numcols <- setdiff(names(tab), "variable")
tab[numcols] <- round(tab[numcols], 3)
# Add a short plain-language interpretation column (ELI5)
interpret <- sapply(seq_len(nrow(tab)), function(i) {
r <- tab[i, ]
if (startsWith(as.character(r$variable), "log_")) {
paste0("Typical (original units) ≈ ", r$backtrans_from_log,
"; median log = ", r$median)
} else {
paste0("Median = ", r$median, "; geom. mean = ", r$geom_mean)
}
})
tab$short_note <- interpret
# Print nicely and save
print(tab, row.names = FALSE)
